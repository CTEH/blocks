= BuildingBlocks

BuildingBlocks is an intricate way of rendering blocks of code, while adding several features that go above and beyond what a simple content_for with yield is capable of doing.

1. It provides the ability to pass parameters to a defined block of code (something content_for with yield is incapable of doing). 
2. It provides "before" and "after" hooks that can render code before and after a specified block of code is rendered (this can be particularly useful when you want to specify a dynamic list of javascript or stylesheet includes after you standard includes).
3. It allows the developer to define a block of code as a global partial, a controller specific partial, or an inline block of code, all with the same syntax usage.
4. (Probably the most powerful aspect) It allows the developer to build complex reusable UI components by essentially providing their own DTD (see the separate project {table_for}[https://github.com/hunterae/table-for] for an example of a nice table builder that was created using minimal code by apply BuildingBlocks).

== Installation

In <b>Rails 3</b>, add this to your Gemfile.

  gem "building-blocks"

== Defining and using blocks

The syntax for defining and using blocks is similar to how content_for and yield are used. At its simplest form:

  <% blocks.define :my_block do %>
    My code to render
  <% end %>
  
  <!-- Elsewhere, you can use the block as follows -->
  <%= blocks.use :my_block %>

== Passing parameters to blocks

Parameters may also be passed into defined blocks:

  <% blocks.define :my_block do |options| %>
    The user of this block passed in "<%= options[:my_parameter] %>" as :my_parameter.
  <% end %>
  
  <!-- Elsewhere, you can use the block as follows -->
  <%= blocks.use :my_block, :my_parameter => "The value I'm passing in"  %>

The rendered output will be: 
  The user of this block passed in "The value I'm passing in" as :my_parameter.

If the anticipated parameters are not passed:
  <%= blocks.use :my_block %>
  
The rendered output will be: 
  The user of this block passed in "" as :my_parameter.

As you can see, the parameters are not required, but you might get unexpected results if you fail to pass in the "necessary" parameters.

== Providing default values for parameters to blocks

In the last example, the parameter the block was expecting was not passed in. For this reason, it is possible to specify default values for the parameters when you define a block. If parameters are passed in when the block is used, the values passed in override the default values.

  <% blocks.define :my_block, :my_parameter_1 => "Parameter 1", :my_parameter_2 => "Parameter 2" do |options| %>
    The values specified are: :my_parameter_1 = "<%= options[:my_parameter_1] %>", :my_parameter_2 = "<%= options[:my_parameter_2] %>"
  <% end %>
  
Now when you use the block, you can specify zero, one, or both of the parameters the block uses:

  <%= blocks.use :my_block %><br />
  <%= blocks.use :my_block, :my_parameter_1 => "New Parameter 1" %><br />
  <%= blocks.use :my_block, :my_parameter_2 => "New Parameter 2" %><br />
  <%= blocks.use :my_block, :my_parameter_1 => "New Parameter 1", :my_parameter_2 => "New Parameter 2" %>

And the user will see:
  The values specified are: :my_parameter_1 = "Parameter 1", :my_parameter_2 = "Parameter 2"
  The values specified are: :my_parameter_1 = "New Parameter 1", :my_parameter_2 = "Parameter 2"
  The values specified are: :my_parameter_1 = "Parameter 1", :my_parameter_2 = "New Parameter 2"
  The values specified are: :my_parameter_1 = "New Parameter 1", :my_parameter_2 = "New Parameter 2"

== Providing a default definition for a block

What happens if you attempt to "use" a block that hasn't been "define"d? Nothing gets rendered.

However, you may want to provide a default definition for a block to "use" if such a block was never "define"d. You can do this as follows:

  <%= blocks.use :my_block, :my_parameter_1 => "Parameter 1" do %>
    This is my default definition of :my_block.
  <% end %>

In this case, BuildingBlocks will see if any block by the name :my_block has ever been defined. When it doesn't find one, it will simply render the default definition and you will see:
  This is my default definition of :my_block.
  
If however, you have defined :my_block elsewhere, it would have used that definition:

  <% blocks.define :my_block do |options| %>
    Some other definition of :my_block with :my_parameter_1 set to "<%= options[:my_parameter_1] %>"
  <% end %>
  
  <%= blocks.use :my_block, :my_parameter_1 => "Parameter 1" do %>
    This is my default definition of :my_block.
  <% end %>
  
The user will see:
  Some other definition of :my_block with :my_parameter_1 set to "Parameter 1"
since the block was defined (i.e. the default definition is not needed)

== Using "before" and "after filters"

"Before" and "After" hooks render code before and after the code produced by a "blocks.use" call. A practical example of this would be adding view-specific javascript and stylesheet includes to a global layout file.

In your application.html layout file, you might use this as follows:

  <html>
    <head>
      <%= blocks.use :includes do %>
        <%= blocks.use :stylesheets do %>
          <%= stylesheet_link_tag "jquery" %>
        <% end %>
        <%= blocks.use :javscripts do %>
          <%= javascript_include_tag "jquery" %>
        <% end %>
      <% end %>
    </head>
    <body>
      <%= yield %>
    </body>
  </html>

Then, in a specific view that is rendering using this layout, you can add stylesheets before or after the list of stylesheets includes, before or after the list of javascript includes, or before or after the entire list of stylesheet and javascript includes. For example, index.html.erb might add in more stylesheets and javascripts:

  <% blocks.before :includes do %>
    <%= stylesheet_link_tag "first_overall_stylesheet" %>
  <% end %>
  
  <% blocks.after :includes do %>
    <%= stylesheet_link_tag "last_overall_stylesheet" %>
  <% end %>
  
  <% blocks.before :stylesheets do %>
    <%= stylesheet_link_tag "stylesheet_before_jquery" %>
  <% end %>
  
  <% blocks.after :stylesheets do %>
    <%= stylesheet_link_tag "stylesheet_after_jquery" %>
  <% end %>
  
  <% blocks.before :javascripts do %>
    <%= javascript_include_tag "javascript_before_jquery" %>
  <% end %>
  
  <% blocks.after :javascripts do %>
    <%= javascript_include_tag "stylesheet_before_jquery" %>
  <% end %>

Now, if index.html.erb is rendered, it will produce code as follows (notice the order):
  <html>
    <head>
      <link href="/stylesheets/first_overall_stylesheet.css" media="screen" rel="stylesheet" type="text/css" />
      <link href="/stylesheets/stylesheet_before_jquery.css" media="screen" rel="stylesheet" type="text/css" />
      <link href="/stylesheets/jquery.css" media="screen" rel="stylesheet" type="text/css" />
      <link href="/stylesheets/stylesheet_after_jquery.css" media="screen" rel="stylesheet" type="text/css" />
      <script src="/javascripts/javascript_before_jquery.js" type="text/javascript"></script>
      <script src="/javascripts/jquery.js" type="text/javascript"></script>
      <script src="/javascripts/javascript_after_jquery.js" type="text/javascript"></script>
      <link href="/stylesheets/last_overall_stylesheet.css" media="screen" rel="stylesheet" type="text/css" />
    </head>
    <body>
    </body>
  </html>

(An alternative syntax to "blocks.before" and "blocks.after" would be, respectively, "blocks.prepend" and "blocks.append")

== MORE COMING SOON...

== Questions or Problems?

If you have any issues with BuildingBlocks which you cannot find the solution to in the documentation, please add an {issue on GitHub}[https://github.com/hunterae/building-blocks/issues] or fork the project and send a pull request.

== Special Thanks

Thanks to Todd Fisher of Captico for implementation help and setup of gem and to Jon Phillips for suggestions and use case help.
